Ideally, when a live player (or bot) is done playing, he or she will
issue a quit request, which arrives at the engine via the live
driver. But more realistically the player quits the game abruptly by,
say, closing a browser window or by otherwise killing a local client
process ungracefully. For this reason the live driver must take
responsibility for detecting even unannounced disconnections and for
sending the engine quit requests on their behalf. Otherwise the
character will remain logged in, and other players will
wonder why it is inert.

Similarly, a driver itself may need to disconnect from the game;
perhaps a developer needs to shut it down for an upgrade.  In this
case the driver should first send the engine quit requests on behalf
of all its characters. Thus a driver will need to maintain a list
(really a set) of its currently managed characters.  But a driver too
may disconnect abruptly.  It might crash, or its connection to the
engine may fail.  Since it will not have had a chance to send quit
requests on behalf of its many characters, they will all be left in
the dead state just described.

To prevent this undesirable outcome, the responsibility for cleaning
up after an abruptly disconnected driver falls on the engine
itself. So it too must maintain lists (sets) of currently playing
characters, each associated with its driver. When a driver suddenly
disappears, the engine must send each character in the corresponding
set back to its home place and make it quit.

The question then is where to put these sets.
Since each driver gets its own driver action in the engine, it might make
sense to put them inside the actions.
An action's companion thread, which watches messages from
the game loop, could be tasked with updating the set whenever it sees a
message confirming that a character has been allowed to join or leave
the game.
In case of sudden disconnection, the companion thread would clean up the
characters in the set, and would then expire.
The advantage of this scheme is that it keeps details about drivers
out of the game loop.

But unfortunately it won't work.
Suppose for example that the driver thread receives from the driver a request
to make character~X join the game, and suppose that the connection dies
immediately after the action pushes this request onto the game queue.
Then there is nothing to stop the companion thread from cleaning up the
characters in its set, and even from expiring altogether, {\em before} it
receives the game loop's confirmation that character~X has joined the game.
X~would then remain permanently logged in, and inert.

Perhaps, then, it is the game loop that should hold the character sets,
one per driver.
Upon sudden disconnection of its driver, a driver thread would then send the
game loop a special request telling it to clean its characters out.
The request would have to carry a label identifying the driver uniquely,
which means that the game engine would have to have already assigned that label
to the driver when the latter first connected.
This already shows the disadvantages of the scheme: it complicates types,
flows, and the game loop itself.

Fortunately there is a third way which both works and is simplest:
rather than put the character set inside the driver action's companion
thread, entrust it to the driver action itself.  As soon as the action
sees a request to make a character join or quit the game, it updates
the set before it pushes the request onto the game queue.  In this way
the set always represents all the characters of interest to the
driver, and if the driver then disconnects abruptly, the cleanup will
not miss any of them.

The game engine is implemented in Haskell,\footnote{It also imports
RPG-specific helper libraries written in Haskell.} the advantages of
which include garbage collection, green threads, immutability of
variables, algebraic data types, type inference, a parametric type
system that includes ad hoc polymorphism plus constraints, lazy
evaluation and the consequent equational reasoning, a terse and
elegant syntax, a large number of convenient libraries, and of
course portability. The disadvantages of Haskell include the lags of
garbage collection, the high consumption of memory
characteristic of lazy languages, and an inability to match the speeds
of a low-level language such as C, at least for most kinds of
computation, though it does
\footlink{outperform the JVM}
{https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/haskell.html}
on several measures.

The overall requirements of the engine include:
\begin{itemize}
    \item {\em Multiplexing.} It must multiplex incoming game requests and
    linearize them in some order.
    \item {\em Event generation.} It must generate events
    corresponding to updates to the database.
    \item {\em Communication.} It must send notifications of those events
    to the appropriate characters.
    \item {\em Consistency.} It must send those notifications in the
    order of the corresponding updates.
\end{itemize}
The engine fulfills these requirements by running a game loop in a dedicated
thread. The game loop has:
\begin{itemize}
    \item A queue of requests, called the \newterm{game queue};
    \item Exclusive access to the game database;
    \item {\em Sending functions} that send event notifications to the
    appropriate characters.
\end{itemize}
On each iteration, the loop pops a request off the queue, services it,
reading or writing the database if necessary, and uses the sending
functions to send the requesting character any resulting values and to
send event notifications to other characters appropriately, as defined
in \secref{play:dynamics}. The game loop does not, and should not,
know how requests are put onto its queue.  Nor should it know how
sending functions work. Requests are pushed onto the game queue by
client threads, as discussed below. To ensure consistency, these
clients should not be given access to the database or the
sending functions.\footnote{Otherwise the client actions would
have to be made into critical sections, and the idiomatic way to
attempt this in Haskell would be to try somehow to embed database
calls in the STM monad. But this monad works by retrying, so it would
end up repeating calls to the database, making the approach
inefficient.}

We note here in passing that we rule out the use of a distributed
stream processor such
as \footlink{Kafka}{https://kafka.apache.org/powered-by}, if only
because its storage of all events would for our purposes require too
much disk space.  The possibility of using other languages or runtimes
is discussed further in \S\ref{subsec:future:impl}.

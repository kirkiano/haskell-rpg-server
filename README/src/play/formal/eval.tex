Define:
\begin{align*}
  \Sigma    & \equiv \text{the set of all possible game states}\\
  \typ{Evt} & \equiv \text{the set of all possible events} \\
  \typ{cid} & \equiv \text{the set of all possible character IDs}
\end{align*}
(For brevity we omit the internal details of a state $\sigma \in
\Sigma$; it simply represents the state of the database.\footnote{For
  example, to model updates of characters' names, we would introduce
  the set $\textsc{Cnames}$ of character names and could define
  functions $\textsc{Cname}: \Sigma \times \typ{cid} \rightarrow
  \textsc{Cnames}$ and $\textsc{ChangeName}: \Sigma \times \typ{cid}
  \times \textsc{Cnames} \rightarrow \Sigma$, where the latter would,
  given input $(\sigma, \mathit{cid}, n)$, return the state $\sigma'$
  such that
  \[ \textsc{Cname}(\sigma', \mathit{cid}') =
  \begin{cases}
    \textsc{Cname}(\sigma, \mathit{cid}\,'), & \text{if}~\mathit{cid}\,' \neq
    \mathit{cid} \\
    n, & \text{otherwise}
  \end{cases}\]
  This is far more formalism than we need.})  Then the denotation
$\mathcal{D}$ of a client's request represents:
\begin{itemize}
\item[i)] the manner in which it might mutate the given state,
\item[ii)] a potential value to be returned to the client,
  and
\item[iii)] the events it might generate, along with the clients
  who need to be notified of them.
\end{itemize}
Formally, therefore,
\[ \mathcal{D}: ~\typ{Req}~ \rightarrow ~\Sigma~
\rightarrow ~~\Sigma \times \typ{Val}_\nothing \times
\powset{\typ{Evt}
  \times \typ{cid}}
\]
where \powset{S} denotes the power set of $S$, and $\typ{Val}_\nothing
\equiv \typ{Val} \cup \{ \nothing \}$ includes the nonvalue $\nothing$ in
case the request is not one for a data value.
